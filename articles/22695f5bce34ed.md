---
title: "Let's Begin frourio!"
emoji: "🧱"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["typescript", "frourio", "serverless", "aws"]
published: false
---

luma ですどうも。

早速ですが、TypeScript 使ってますか。今回は TypeScript フルスタックフレームワークであるところの frourio を更に簡単に始めるべく、 [begin.com](https://begin.com) というサービスを使って速攻で開発を開始できるようにしてみました。

[![Deploy to Begin](https://static.begin.com/deploy-to-begin.svg)](https://begin.com/apps/create?template=https://github.com/LumaKernel/begin-frourio-next-app)

一切の環境変数の設定もいらず、上記のリンク先でワンクリックする (なお事前に [begin.com](https://begin.com) にログインをしておく) だけで GitHub にクローンして、CI/CD までやってくれて、DB もセットアップされます。また、ローカルの開発も `npm i && npm run start` だけで開始できます。開発用 DB のセットアップはいりません。CI/CD もプッシュするだけ、リリースも GUI で簡単に行なえます。

https://github.com/LumaKernel/begin-frourio-next-app

## セットアップ後の進め方

### ボタンを押したあと

開発をすすめるには、対象の GitHub リポジトリをローカルにクローンしましょう。 

```bash
git clone https://.../my-begin-frourio`
```

そしたら、開発用のサーバーを起動します。

```bash
npm i
npm run start
```

露出されるエンドポイントは以下です。

- [http://localhost:3000](http://localhost:3000): フロントエンド
- [http://localhost:3333](http://localhost:3333): バックエンド

なお、バックエンドは、フロントエンドがビルドされて `/out` に出力されているとそちらを返します。これはちょうど [begin.com](https://begin.com) がこちらの単一のエンドポイントで動いているということですね。開発時に最新のものと混乱しないように [http://localhost:3000](http://localhost:3000) を開いて基本的には開発を進めましょう。

:::message
ポート番号を変えたい場合は `package.json` の以下のスクリプトを編集してください:
  - フロントエンド: `start:next`: 例: `next dev --port 30000`
  - バックエンド: `start:api`: 例: `cross-env NODE_ENV=testing ARC_LOCAL=1 npx sandbox --port 33333`
:::


### frourio エンドポイントを追加

さっそく frourio エンドポイントを作成してみましょう。ここからは `bash` コマンドで基本的には書いていきますが、 VSCode 上の操作などでも問題ありません。

```bash
mkdir ./api/article
# 一瞬待って、
ls ./api/article
$relay.ts  controller.ts  index.ts
```

なんかありますね！ `index.ts` に API の定義を、 `controller.ts` に API の実装を書いていくわけです！

### APIの定義

とりあえず雑に `index.ts` を以下のように編集します。

```ts
export interface Article {
  key: string;
  slug?: string;
  title?: string;
  author?: string;
  body?: string;
  created?: number;
  updated?: number;
}

export type ArticleSummary = Pick<Article, 'author' | 'title' | 'slug' | 'updated'>;

export type Methods = {
  get: {
    query?: {
      cursor?: string;
    };
    resBody: {
      list: ArticleSummary[];
      cursor: string | undefined;
    };
  };
  post: {
    reqBody: Omit<Article, 'key'>;
    resBody: Article;
  };
};
```

`Article` は `key` が検索用のユニークな鍵になります。 `@begin/data` ではこの `key: string` を用いることになります。

`controller.ts` もこんな感じに編集してみます。

```ts
import data from '@begin/data';
import { Article, ArticleSummary } from '.';
import { defineController } from './$relay';

const toSummary = (article: Article): ArticleSummary => {
  return {
    slug: article.slug,
    title: article.title,
    author: article.author,
    updated: article.updated,
  };
};

const table = 'articles';

export default defineController(() => ({
  get: async ({ query }) => {
    const cursor = query?.cursor;
    const res = await data.get({ table, cursor });
    const articles: Article[] = [...res];
    const nextCursor = res.cursor;
    const summaries: ArticleSummary[] = articles.map(toSummary);
    return {
      status: 200,
      body: {
        list: summaries,
        cursor: nextCursor,
      },
    };
  },
  post: async ({ body }) => {
    const article: Article = await data.set({ table, body });
    return {
      status: 201,
      body: article,
    };
  },
}));
```

なんとなくですが `@begin/data` の使い方がわかっていただけたのではないかと思います！


`mkdir ./api/article/_articleSlug` を行い、フロントエンドも作成して... あ、続きは各自でお願いします！

`./api/tasks` のほうに完全な CRUD のサンプルがありますので是非参照してください。

また、 `data.page(...)` という `AsyncIterable` な関数も用意されているのでこちらでもいいかもしれません。

```ts
const list = [];
for await (const page of data.page({ table })) {
  list.push(...page);
}
```

シンプルで物足りないと感じる部分もあるかと思いますが、アイデアをちょっと試してみるのに DB が無料でこんなに簡単に使えるのは嬉しいですね！

### ステージング環境へデプロイ

一連の作業が済んだら push して staging 環境にデプロイしましょう。

```bash
git add .
git commit -m "✨ すごくいいかんじ"
git push origin master
```

[begin.com](https://begin.com) のダッシュボードで結果が確認できます。

## プロダクション環境へデプロイ

[begin.com](https://begin.com) のダッシュボードから Deploy to Production をクリックします。

![](/images/2021/lets-begin-frourio/deploy-to-production.jpg)

すると、いまだかつてみたことないバージョニング UI 。便利だなあ。ホントかな。Circle CI だったら Manual Approval はありますけど、Manual Versioning はなかったですからね！！ね！

## Begin.com とはなにか

此処から先は詳細な [begin.com](https://begin.com) の説明に移ります。

### Architect Serverless Framework

みなさん、 [Serverless Framework](https://www.serverless.com/) は馴染み深い方も多いのではないかともいます。 [Architect Serverless Framework](https://v5.arc.codes/) はそこと同位置にあるサーバーレスフレームワークになります。 Serverless Framework で柔軟な選択ができるのに対し、Architect では AWS に絞られています。具体的には以下のサービスによって構成されます。

- Lambda
- API Gateway
- Route53
- CloudFront
- CloudFormation
- S3
- Simple Notification Service
- Simple Queue Service
- CloudWatch Events
- DynamoDB
- Parameter Store

また、大きな特徴として、 API GW や DynamoDB, SQS, CloudWatch Events によるスケジュール実行といったことをローカルでオンメモリで動くようにラップしてくれており、特に設定を必要とせずに使えるようにしてくれます。

詳細は公式ページを参照してください。

### Begin.com

Begin.com は Architect Serverless Framework の実装の一つということになります。一応自分の AWS 環境を使うプランもあるようです。
無料プランで 5 つまでプロジェクトを作成可能です。ふとっぱら！

### Begin Data

[`@begin/data`](https://www.npmjs.com/package/@begin/data) という名前で公開されている DynamoDB のハイレベルのラッパーです。
ローカルではオンメモリで公開されたインターフェースが動くようになっています。 DynamoDB が動くわけじゃないです。

## 最後に

使っていると `@begin/data` にあれがないこれがないとなるかもしれませんが、そうなったら自分で [prisma](https://prisma.io/) とか [AWS SDK](https://www.npmjs.com/package/aws-sdk) 使ってセットアップしましょう...

物によってはこれで十分使えるものもありそう。アイデア次第ですね！！

## Let's continue frourio!

最後までお読みいただきありがとうございました 😊
